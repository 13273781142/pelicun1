

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pelicun.uq &mdash; pelicun 1.0.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/css/custom.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> pelicun
          

          
          </a>

          
            
            
              <div class="version">
                1.0.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../features.html">Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../license.html">Copyright and license</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../source/pelicun.html">API documentation</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">pelicun</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>pelicun.uq</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pelicun.uq</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1">#</span>
<span class="c1"># Copyright (c) 2018 Leland Stanford Junior University</span>
<span class="c1"># Copyright (c) 2018 The Regents of the University of California</span>
<span class="c1">#</span>
<span class="c1"># This file is part of pelicun.</span>
<span class="c1">#</span>
<span class="c1"># Redistribution and use in source and binary forms, with or without</span>
<span class="c1"># modification, are permitted provided that the following conditions are met:</span>
<span class="c1">#</span>
<span class="c1"># 1. Redistributions of source code must retain the above copyright notice,</span>
<span class="c1"># this list of conditions and the following disclaimer.</span>
<span class="c1">#</span>
<span class="c1"># 2. Redistributions in binary form must reproduce the above copyright notice,</span>
<span class="c1"># this list of conditions and the following disclaimer in the documentation</span>
<span class="c1"># and/or other materials provided with the distribution.</span>
<span class="c1">#</span>
<span class="c1"># 3. Neither the name of the copyright holder nor the names of its contributors</span>
<span class="c1"># may be used to endorse or promote products derived from this software without</span>
<span class="c1"># specific prior written permission.</span>
<span class="c1">#</span>
<span class="c1"># THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</span>
<span class="c1"># AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span>
<span class="c1"># IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span>
<span class="c1"># ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE</span>
<span class="c1"># LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</span>
<span class="c1"># CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span>
<span class="c1"># SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span>
<span class="c1"># INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span>
<span class="c1"># CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</span>
<span class="c1"># ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span>
<span class="c1"># POSSIBILITY OF SUCH DAMAGE.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the BSD 3-Clause License along with</span>
<span class="c1"># pelicun. If not, see &lt;http://www.opensource.org/licenses/&gt;.</span>
<span class="c1">#</span>
<span class="c1"># Contributors:</span>
<span class="c1"># Adam Zsarn√≥czay</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module defines constants, classes and methods for uncertainty</span>
<span class="sd">quantification in pelicun.</span>

<span class="sd">.. rubric:: Contents</span>

<span class="sd">.. autosummary::</span>

<span class="sd">    RandomVariable</span>
<span class="sd">    RandomVariableSubset</span>

<span class="sd">    tmvn_rvs</span>
<span class="sd">    mvn_orthotope_density</span>
<span class="sd">    tmvn_MLE</span>


<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">.base</span> <span class="k">import</span> <span class="o">*</span>

<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="k">import</span> <span class="n">norm</span><span class="p">,</span> <span class="n">truncnorm</span><span class="p">,</span> <span class="n">multivariate_normal</span><span class="p">,</span> <span class="n">multinomial</span>
<span class="kn">from</span> <span class="nn">scipy.stats.mvn</span> <span class="k">import</span> <span class="n">mvndst</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="k">import</span> <span class="n">minimize</span><span class="p">,</span> <span class="n">differential_evolution</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="k">import</span> <span class="n">deepcopy</span>

<div class="viewcode-block" id="tmvn_rvs"><a class="viewcode-back" href="../../source/pelicun.uq.html#pelicun.uq.tmvn_rvs">[docs]</a><span class="k">def</span> <span class="nf">tmvn_rvs</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">COV</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">upper</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sample a truncated MVN distribution.</span>

<span class="sd">    Truncation of the multivariate normal distribution is currently considered</span>
<span class="sd">    through rejection sampling. The applicability of this method is limited by</span>
<span class="sd">    the amount of probability density enclosed by the hyperrectangle defined by</span>
<span class="sd">    the truncation limits. The lower that density is, the more samples will</span>
<span class="sd">    need to be rejected which makes the method inefficient when the tails of</span>
<span class="sd">    the MVN shall be sampled in high-dimensional space. Such cases can be</span>
<span class="sd">    handled by a Gibbs sampler, which is a planned future feature of this</span>
<span class="sd">    function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mu: float scalar or ndarray</span>
<span class="sd">        Mean(s) of the non-truncated distribution.</span>
<span class="sd">    COV: float ndarray</span>
<span class="sd">        Covariance matrix of the non-truncated distribution.</span>
<span class="sd">    lower: float vector, optional, default: None</span>
<span class="sd">        Lower bound(s) for the truncated distributions. A scalar value can be</span>
<span class="sd">        used for a univariate case, while a list of bounds is expected in</span>
<span class="sd">        multivariate cases. If the distribution is non-truncated from below</span>
<span class="sd">        in a subset of the dimensions, assign an infinite value</span>
<span class="sd">        (i.e. -numpy.inf) to those dimensions.</span>
<span class="sd">    upper: float vector, optional, default: None</span>
<span class="sd">        Upper bound(s) for the truncated distributions. A scalar value can be</span>
<span class="sd">        used for a univariate case, while a list of bounds is expected in</span>
<span class="sd">        multivariate cases. If the distribution is non-truncated from above</span>
<span class="sd">        in a subset of the dimensions, assign an infinite value</span>
<span class="sd">        (i.e. numpy.inf) to those dimensions.</span>
<span class="sd">    size: int</span>
<span class="sd">        Number of samples requested.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    samples: float ndarray</span>
<span class="sd">        Samples generated from the truncated distribution.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mu</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">():</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">mu</span><span class="p">])</span>
        <span class="n">COV</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">COV</span><span class="p">])</span>

    <span class="c1"># if there are no bounds, simply sample an MVN distribution</span>
    <span class="k">if</span> <span class="n">lower</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">upper</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

        <span class="n">samples</span> <span class="o">=</span> <span class="n">multivariate_normal</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">mean</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">cov</span><span class="o">=</span><span class="n">COV</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># first, get the rejection rate</span>
        <span class="n">alpha</span><span class="p">,</span> <span class="n">eps_alpha</span> <span class="o">=</span> <span class="n">mvn_orthotope_density</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">COV</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">)</span>

        <span class="c1"># initialize the data for sample collection</span>
        <span class="n">sample_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">lower</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lower</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">ndim</span><span class="p">)</span> <span class="o">*</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">if</span> <span class="n">upper</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">upper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">ndim</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>

        <span class="c1"># If the error in the alpha estimate is too large, then we are</span>
        <span class="c1"># beyond the applicability limits of the function used for</span>
        <span class="c1"># estimating alpha. Raise an error in such a case</span>
        <span class="k">if</span> <span class="n">alpha</span> <span class="o">&lt;=</span> <span class="mf">100.</span> <span class="o">*</span> <span class="n">eps_alpha</span><span class="p">:</span>  <span class="c1"># i.e. max. error is limited at 1%</span>
            <span class="c1">#print(alpha, eps_alpha)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The density of the joint probability distribution within the &quot;</span>
                <span class="s2">&quot;truncation limits is too small and cannot be estimated with &quot;</span>
                <span class="s2">&quot;sufficiently high accuracy. This is most probably due to &quot;</span>
                <span class="s2">&quot;incorrect limits set for the distribution.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># If the rejection rate is sufficiently low, perform rejection sampling</span>
        <span class="c1"># Note: the minimum rate is set to zero until a Gibbs sampler is</span>
        <span class="c1"># implemented, but a warning message is displayed for anything below</span>
        <span class="c1"># 1e-3</span>
        <span class="k">if</span> <span class="n">alpha</span> <span class="o">&lt;</span> <span class="mf">1e-3</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="ne">UserWarning</span><span class="p">(</span>
                <span class="s2">&quot;The rejection rate for sampling the prescribed truncated MVN &quot;</span>
                <span class="s2">&quot;distribution is higher than 0.999. This makes sampling with &quot;</span>
                <span class="s2">&quot;our current implementation very resource-intensive and &quot;</span>
                <span class="s2">&quot;inefficient. If you need to sample such parts of MVN &quot;</span>
                <span class="s2">&quot;distributions, please let us know and we will improve &quot;</span>
                <span class="s2">&quot;this function in the future.&quot;</span>
            <span class="p">))</span>
        <span class="k">if</span> <span class="n">alpha</span> <span class="o">&gt;</span> <span class="mf">0.</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">sample_count</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">:</span>

                <span class="c1"># estimate the required number of samples</span>
                <span class="n">req_samples</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="mf">1.1</span><span class="o">*</span><span class="p">(</span><span class="n">size</span><span class="o">-</span><span class="n">sample_count</span><span class="p">)</span><span class="o">/</span><span class="n">alpha</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>

                <span class="c1"># generate the raw samples</span>
                <span class="n">raw_samples</span> <span class="o">=</span> <span class="n">multivariate_normal</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">COV</span><span class="p">,</span>
                                                      <span class="n">size</span><span class="o">=</span><span class="n">req_samples</span><span class="p">)</span>

                <span class="c1"># remove the samples that are outside the truncation limits</span>
                <span class="n">good_ones</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="n">raw_samples</span><span class="o">&gt;</span><span class="n">lower</span><span class="p">,</span> <span class="n">raw_samples</span><span class="o">&lt;</span><span class="n">upper</span><span class="p">],</span>
                                   <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">good_ones</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">good_ones</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

                <span class="n">new_samples</span> <span class="o">=</span> <span class="n">raw_samples</span><span class="p">[</span><span class="n">good_ones</span><span class="p">]</span>

                <span class="c1"># add the new samples to the pool of samples</span>
                <span class="k">if</span> <span class="n">sample_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">samples</span><span class="p">,</span> <span class="n">new_samples</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">samples</span> <span class="o">=</span> <span class="n">new_samples</span>

                <span class="c1"># check the number of available samples and generate more if</span>
                <span class="c1"># needed</span>
                <span class="n">sample_count</span> <span class="o">=</span> <span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">samples</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[:</span><span class="n">size</span><span class="p">]</span>

        <span class="c1">#else:</span>
        <span class="c1"># TODO: Gibbs sampler</span>

    <span class="k">return</span> <span class="n">samples</span></div>

<div class="viewcode-block" id="mvn_orthotope_density"><a class="viewcode-back" href="../../source/pelicun.uq.html#pelicun.uq.mvn_orthotope_density">[docs]</a><span class="k">def</span> <span class="nf">mvn_orthotope_density</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">COV</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">upper</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Estimate the probability density within a hyperrectangle for an MVN distr.</span>

<span class="sd">    Use the method of Alan Genz (1992) to estimate the probability density</span>
<span class="sd">    of a multivariate normal distribution within an n-orthotope (i.e.,</span>
<span class="sd">    hyperrectangle) defined by its lower and upper bounds. Limits can be</span>
<span class="sd">    relaxed in any direction by assigning infinite bounds (i.e. numpy.inf).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mu: float scalar or ndarray</span>
<span class="sd">        Mean(s) of the non-truncated distribution.</span>
<span class="sd">    COV: float ndarray</span>
<span class="sd">        Covariance matrix of the non-truncated distribution</span>
<span class="sd">    lower: float vector, optional, default: None</span>
<span class="sd">        Lower bound(s) for the truncated distributions. A scalar value can be</span>
<span class="sd">        used for a univariate case, while a list of bounds is expected in</span>
<span class="sd">        multivariate cases. If the distribution is non-truncated from below</span>
<span class="sd">        in a subset of the dimensions, use either `None` or assign an infinite</span>
<span class="sd">        value (i.e. -numpy.inf) to those dimensions.</span>
<span class="sd">    upper: float vector, optional, default: None</span>
<span class="sd">        Upper bound(s) for the truncated distributions. A scalar value can be</span>
<span class="sd">        used for a univariate case, while a list of bounds is expected in</span>
<span class="sd">        multivariate cases. If the distribution is non-truncated from above</span>
<span class="sd">        in a subset of the dimensions, use either `None` or assign an infinite</span>
<span class="sd">        value (i.e. numpy.inf) to those dimensions.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    alpha: float</span>
<span class="sd">        Estimate of the probability density within the hyperrectangle</span>
<span class="sd">    eps_alpha: float</span>
<span class="sd">        Estimate of the error in alpha.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># process the inputs and get the number of dimensions</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mu</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">():</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">mu</span><span class="p">])</span>
        <span class="n">COV</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">COV</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">COV</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">COV</span><span class="p">)</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">COV</span><span class="p">))</span>
    <span class="n">corr</span> <span class="o">=</span> <span class="n">COV</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span><span class="n">sig</span><span class="p">)</span>

    <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">lower</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">lower</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">ndim</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">lower</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">lower</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">upper</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">upper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">ndim</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">upper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">upper</span><span class="p">)</span>

    <span class="c1"># standardize the truncation limits</span>
    <span class="n">lower</span> <span class="o">=</span> <span class="p">(</span><span class="n">lower</span><span class="o">-</span><span class="n">mu</span><span class="p">)</span><span class="o">/</span><span class="n">sig</span>
    <span class="n">upper</span> <span class="o">=</span> <span class="p">(</span><span class="n">upper</span><span class="o">-</span><span class="n">mu</span><span class="p">)</span><span class="o">/</span><span class="n">sig</span>

    <span class="c1"># prepare the flags for infinite bounds (these are needed for the mvndst</span>
    <span class="c1"># function)</span>
    <span class="n">lowinf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">(</span><span class="n">lower</span><span class="p">)</span>
    <span class="n">uppinf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isposinf</span><span class="p">(</span><span class="n">upper</span><span class="p">)</span>
    <span class="n">infin</span> <span class="o">=</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">ndim</span><span class="p">)</span>

    <span class="n">np</span><span class="o">.</span><span class="n">putmask</span><span class="p">(</span><span class="n">infin</span><span class="p">,</span> <span class="n">lowinf</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">putmask</span><span class="p">(</span><span class="n">infin</span><span class="p">,</span> <span class="n">uppinf</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">putmask</span><span class="p">(</span><span class="n">infin</span><span class="p">,</span> <span class="n">lowinf</span><span class="o">*</span><span class="n">uppinf</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># prepare the correlation coefficients</span>
    <span class="k">if</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">correl</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">correl</span> <span class="o">=</span> <span class="n">corr</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">tril_indices</span><span class="p">(</span><span class="n">ndim</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span>

    <span class="c1"># estimate the density</span>
    <span class="n">eps_alpha</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">__</span> <span class="o">=</span> <span class="n">mvndst</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">infin</span><span class="p">,</span> <span class="n">correl</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">eps_alpha</span></div>

<div class="viewcode-block" id="tmvn_MLE"><a class="viewcode-back" href="../../source/pelicun.uq.html#pelicun.uq.tmvn_MLE">[docs]</a><span class="k">def</span> <span class="nf">tmvn_MLE</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span>
             <span class="n">tr_lower</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tr_upper</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">censored_count</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">det_lower</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">det_upper</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">alpha_lim</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fit a truncated multivariate normal distribution to samples using MLE.</span>

<span class="sd">    The number of dimensions of the distribution function are inferred from the</span>
<span class="sd">    shape of the sample data. Censoring is automatically considered if the</span>
<span class="sd">    number of censored samples and the corresponding detection limits are</span>
<span class="sd">    provided. Infinite or unspecified truncation limits lead to fitting a</span>
<span class="sd">    non-truncated normal distribution in that dimension.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    samples: ndarray</span>
<span class="sd">        Raw data that serves as the basis of estimation. The number of samples</span>
<span class="sd">        equals the number of columns and each row introduces a new feature. In</span>
<span class="sd">        other words: a list of sample lists is expected where each sample list</span>
<span class="sd">        is a collection of samples of one variable.</span>
<span class="sd">    tr_lower: float vector, optional, default: None</span>
<span class="sd">        Lower bound(s) for the truncated distributions. A scalar value can be</span>
<span class="sd">        used for a univariate case, while a list of bounds is expected in</span>
<span class="sd">        multivariate cases. If the distribution is non-truncated from below</span>
<span class="sd">        in a subset of the dimensions, use either `None` or assign an infinite</span>
<span class="sd">        value (i.e. -numpy.inf) to those dimensions.</span>
<span class="sd">    tr_upper: float vector, optional, default: None</span>
<span class="sd">        Upper bound(s) for the truncated distributions. A scalar value can be</span>
<span class="sd">        used for a univariate case, while a list of bounds is expected in</span>
<span class="sd">        multivariate cases. If the distribution is non-truncated from above</span>
<span class="sd">        in a subset of the dimensions, use either `None` or assign an infinite</span>
<span class="sd">        value (i.e. numpy.inf) to those dimensions.</span>
<span class="sd">    censored_count: int, optional, default: None</span>
<span class="sd">        The number of censored samples that are beyond the detection limits.</span>
<span class="sd">        All samples outside the detection limits are aggregated into one set.</span>
<span class="sd">        This works the same way in one and in multiple dimensions. Prescription</span>
<span class="sd">        of specific censored sample counts for sub-regions of the input space</span>
<span class="sd">        outside the detection limits is not supported.</span>
<span class="sd">    det_lower: float ndarray, optional, default: None</span>
<span class="sd">        Lower detection limit(s) for censored data. In multivariate cases the</span>
<span class="sd">        limits need to be defined as a vector; a scalar value is sufficient in</span>
<span class="sd">        a univariate case. If the data is not censored from below in a</span>
<span class="sd">        particular dimension, assign None to that position of the ndarray.</span>
<span class="sd">    det_upper: float ndarray, optional, default: None</span>
<span class="sd">        Upper detection limit(s) for censored data. In multivariate cases the</span>
<span class="sd">        limits need to be defined as a vector; a scalar value is sufficient in</span>
<span class="sd">        a univariate case. If the data is not censored from above in a</span>
<span class="sd">        particular dimension, assign None to that position of the ndarray.</span>
<span class="sd">    alpha_lim: float, optional, default:None</span>
<span class="sd">        Introduces a lower limit to the probability density within the</span>
<span class="sd">        n-orthotope defined by the truncation limits. Assigning a reasonable</span>
<span class="sd">        minimum (such as 1e-4) can be useful when the mean of the distribution</span>
<span class="sd">        is several standard deviations from the truncation limits and the</span>
<span class="sd">        sample size is small. Such cases without a limit often converge to</span>
<span class="sd">        distant means with inflated variances. Besides being incorrect</span>
<span class="sd">        estimates, those solutions only offer negligible reduction in the</span>
<span class="sd">        negative log likelihood, while making subsequent sampling of the</span>
<span class="sd">        truncated normal distribution very challenging.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mu: float scalar or ndarray</span>
<span class="sd">        Mean of the fitted probability distribution. A vector of means is</span>
<span class="sd">        returned in a multivariate case.</span>
<span class="sd">    COV: float scalar or 2D ndarray</span>
<span class="sd">        Covariance matrix of the fitted probability distribution. A 2D square</span>
<span class="sd">        ndarray is returned in a multi-dimensional case, while a single</span>
<span class="sd">        variance (not standard deviation!) value is returned in a univariate</span>
<span class="sd">        case.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">detection limits:&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">det_lower</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">det_upper</span><span class="p">)</span>
    <span class="c1"># extract some basic information about the number of dimensions and the</span>
    <span class="c1"># number of samples from raw data</span>
    <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">samples</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">ndims</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">nsamples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
        <span class="n">samplesT</span> <span class="o">=</span> <span class="n">samples</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ndims</span><span class="p">,</span> <span class="n">nsamples</span> <span class="o">=</span> <span class="n">samples</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">samplesT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>

    <span class="n">mu_hat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">samplesT</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># replace zero standard dev with negligible standard dev</span>
    <span class="k">if</span> <span class="n">ndims</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">sig_hat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mf">1e-6</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">samplesT</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sig_hat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">samplesT</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">sig_zero_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sig_hat</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">sig_hat</span><span class="p">[</span><span class="n">sig_zero_id</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-6</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">mu_hat</span><span class="p">[</span><span class="n">sig_zero_id</span><span class="p">])</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">det_lower</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">det_upper</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">det_upper_adj</span> <span class="o">=</span> <span class="p">(</span><span class="n">det_upper</span> <span class="o">-</span> <span class="n">mu_hat</span><span class="p">)</span> <span class="o">/</span> <span class="n">sig_hat</span>
        <span class="n">det_lower_adj</span> <span class="o">=</span> <span class="p">(</span><span class="n">det_lower</span> <span class="o">-</span> <span class="n">mu_hat</span><span class="p">)</span> <span class="o">/</span> <span class="n">sig_hat</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">tr_lower</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">tr_upper</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">tr_upper_adj</span> <span class="o">=</span> <span class="p">(</span><span class="n">tr_upper</span> <span class="o">-</span> <span class="n">mu_hat</span><span class="p">)</span> <span class="o">/</span> <span class="n">sig_hat</span>
        <span class="n">tr_lower_adj</span> <span class="o">=</span> <span class="p">(</span><span class="n">tr_lower</span> <span class="o">-</span> <span class="n">mu_hat</span><span class="p">)</span> <span class="o">/</span> <span class="n">sig_hat</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">method of moments estimates:&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">mu_hat</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">sig_hat</span><span class="p">)</span>

    <span class="n">samplesT</span> <span class="o">=</span> <span class="p">(</span><span class="n">samplesT</span> <span class="o">-</span> <span class="n">mu_hat</span><span class="p">)</span> <span class="o">/</span> <span class="n">sig_hat</span>

    <span class="n">mu_hatc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">samplesT</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">sig_hatc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">samplesT</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ndims</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">sig_hatc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sig_hatc</span> <span class="o">=</span> <span class="mf">0.999</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sig_zero_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sig_hatc</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">sig_hatc</span><span class="p">[</span><span class="n">sig_zero_id</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.999</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">standardized estimates:&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">mu_hatc</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">sig_hatc</span><span class="p">)</span>

    <span class="c1"># define initial values of distribution parameters using simple estimates</span>
    <span class="k">if</span> <span class="n">ndims</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1">#mu_init = np.mean(samples)</span>
        <span class="c1"># we perturb the mu to improve optimization</span>
        <span class="n">mu_init</span> <span class="o">=</span> <span class="n">mu_hatc</span> <span class="o">+</span> <span class="n">sig_hatc</span><span class="o">*</span><span class="mf">0.1</span>
        <span class="c1"># use biased estimate for std, because MLE will converge to that anyway</span>
        <span class="c1">#sig_init = np.std(samples, ddof=0)</span>
        <span class="n">sig_init</span> <span class="o">=</span> <span class="n">sig_hatc</span>
        <span class="c1"># replace zero variance with negligible variance</span>
        <span class="k">if</span> <span class="n">sig_init</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="n">sig_init</span> <span class="o">=</span> <span class="mf">1e-6</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">mu_init</span><span class="p">)</span>
        <span class="n">rho_init</span><span class="o">=</span><span class="p">()</span>
        <span class="n">fit_rho</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># prepare a vector of initial values</span>
        <span class="n">inits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">mu_init</span><span class="p">,</span> <span class="n">sig_init</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#mu_init = np.mean(samples, axis=1)</span>
        <span class="n">mu_init</span> <span class="o">=</span> <span class="n">mu_hatc</span>
        <span class="c1"># use biased estimate, see comment above</span>
        <span class="c1">#sig_init = np.std(samples, axis=1, ddof=0)</span>
        <span class="n">sig_init</span> <span class="o">=</span> <span class="n">sig_hatc</span>
        <span class="c1"># replace zero variance with negligible variance</span>
        <span class="n">sig_zero_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sig_init</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">sig_init</span><span class="p">[</span><span class="n">sig_zero_id</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-6</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">mu_init</span><span class="p">[</span><span class="n">sig_zero_id</span><span class="p">])</span>
        <span class="c1"># try to create the correlation matrix</span>
        <span class="n">rho_init</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">samplesT</span><span class="p">))</span>
        <span class="c1"># If there is not enough samples, or the samples are not from a</span>
        <span class="c1"># multivariate normal distribution, the rho values might be nan.</span>
        <span class="c1"># First, we replace the nan values with zeros. Then, check if the</span>
        <span class="c1"># resulting matrix is positive semidefinite. If not, then rather than</span>
        <span class="c1"># trying to patch it, in this case, we assume uncorrelated</span>
        <span class="c1"># samples and make sure that at least the mu and sig values will be OK.</span>
        <span class="n">rho_init</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">rho_init</span><span class="p">)</span>
        <span class="n">pos_sem_def</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">rho_init</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mf">0.</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pos_sem_def</span><span class="p">:</span>
        <span class="c1">#if np.isnan(np.sum(rho_init.flatten())):</span>
            <span class="n">show_warning</span><span class="p">(</span><span class="s2">&quot;The number of samples is not sufficient to estimate &quot;</span>
                <span class="s2">&quot;the correlation matrix. We assume uncorrelated EDPs.&quot;</span><span class="p">)</span>
            <span class="n">rho_init</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">rho_init</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="c1">#rho_init = np.ones(rho_init.shape)*0.0       #*0.7</span>
        <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">rho_init</span><span class="p">,</span><span class="mf">1.0</span><span class="p">)</span>
        <span class="c1"># collect the independent values (i.e. elements above the main</span>
        <span class="c1"># diagonal) from the correlation matrix in a list</span>
        <span class="n">rho_init_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">triu_indices</span><span class="p">(</span><span class="n">ndims</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">rho_init_list</span> <span class="o">=</span> <span class="n">rho_init</span><span class="p">[</span><span class="n">rho_init_ids</span><span class="p">]</span>
        <span class="c1"># save the ids of the elements below the main diagonal for future use</span>
        <span class="n">rho_init_ids2</span> <span class="o">=</span> <span class="n">rho_init_ids</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># prepare a vector of initial values</span>
        <span class="c1"># if there is too few samples, we do not fit the correlation matrix</span>
        <span class="n">fit_rho</span> <span class="o">=</span> <span class="n">nsamples</span> <span class="o">&gt;</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">ndims</span><span class="o">**</span><span class="mf">2.0</span>
        <span class="k">if</span> <span class="n">fit_rho</span><span class="p">:</span>
            <span class="n">inits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">mu_init</span><span class="p">,</span> <span class="n">sig_init</span><span class="p">,</span> <span class="n">rho_init_list</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">inits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">mu_init</span><span class="p">,</span> <span class="n">sig_init</span><span class="p">])</span>

    <span class="c1"># If the distribution is censored or truncated, check if the number of</span>
    <span class="c1"># samples is greater than the number of unknowns. If not, show a warning.</span>
    <span class="k">if</span> <span class="n">fit_rho</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(((</span><span class="n">tr_lower</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">tr_upper</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span><span class="n">det_lower</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">det_upper</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">))</span>
           <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">inits</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">nsamples</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;samples:&#39;</span><span class="p">,</span><span class="n">nsamples</span><span class="p">,</span><span class="s1">&#39;unknowns:&#39;</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">inits</span><span class="p">))</span>
            <span class="n">show_warning</span><span class="p">(</span>
                <span class="s2">&quot;The number of samples is less than the number of unknowns. There &quot;</span>
                <span class="s2">&quot;is no unique solution available for such a case. Expect a poor &quot;</span>
                <span class="s2">&quot;estimate of the distribution (especially the covariance matrix). &quot;</span>
                <span class="s2">&quot;Either provide more samples, or relax the assumed dependencies &quot;</span>
                <span class="s2">&quot;between variables, or remove the truncation/detection limits to &quot;</span>
                <span class="s2">&quot;improve the situation.&quot;</span>
            <span class="p">)</span>

    <span class="c1"># define the bounds for the distribution parameters</span>
    <span class="c1"># mu is not bounded</span>
    <span class="c1">#mu_bounds = [(-np.inf, np.inf) for t in range(ndims)]</span>
    <span class="n">mu_bounds</span> <span class="o">=</span> <span class="p">[(</span><span class="o">-</span><span class="mf">10.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndims</span><span class="p">)]</span>
    <span class="c1"># sig is bounded below at (0</span>
    <span class="c1">#sig_bounds = [(np.nextafter(0,1), np.inf) for s in range(ndims)]</span>
    <span class="n">sig_bounds</span> <span class="o">=</span> <span class="p">[(</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">20.0</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndims</span><span class="p">)]</span>
    <span class="c1"># rho is bounded on both sides by (-1,1)</span>
    <span class="c1"># Note that -1.0 and 1.0 are not allowed to avoid numerical problems due to</span>
    <span class="c1"># a singular and/or non-positive definite covariance matrix</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">ndims</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">fit_rho</span><span class="p">)):</span>
        <span class="n">rho_bounds</span> <span class="o">=</span> <span class="p">[(</span><span class="o">-</span><span class="mf">1.</span><span class="o">+</span><span class="mf">1e-3</span><span class="p">,</span> <span class="mf">1.</span><span class="o">-</span><span class="mf">1e-3</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rho_init_list</span><span class="p">))]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># there is no need for rho bounds in a univariate case and when we do not fit rho</span>
        <span class="n">rho_bounds</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># create a lower and an upper bounds vector</span>
    <span class="c1">#bounds = mu_bounds + sig_bounds + rho_bounds</span>
    <span class="n">bounds</span> <span class="o">=</span> <span class="n">mu_bounds</span> <span class="o">+</span> <span class="n">sig_bounds</span> <span class="o">+</span> <span class="n">rho_bounds</span>
    <span class="n">bnd_lower</span><span class="p">,</span> <span class="n">bnd_upper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">bounds</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">bounds:&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">bounds</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">sig_bounds</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fit_rho</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">rho_bounds</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">initial values:&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">inits</span><span class="p">)</span>

    <span class="c1"># create a convenience function that converts a vector of distribution</span>
    <span class="c1"># parameters to the standard mu and COV arrays</span>
    <span class="k">def</span> <span class="nf">_get_mu_COV</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">unbiased</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The unbiased flag controls if the bias in standard deviation</span>
<span class="sd">        estimates shall be corrected during conversion.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ndims</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">mu</span><span class="p">,</span> <span class="n">COV</span> <span class="o">=</span> <span class="n">params</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="n">params</span><span class="p">[:</span><span class="n">ndims</span><span class="p">]</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">ndims</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">ndims</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">unbiased</span><span class="p">:</span>
                <span class="n">sig</span> <span class="o">=</span> <span class="n">sig</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">nsamples</span> <span class="o">/</span> <span class="p">(</span><span class="n">nsamples</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>

            <span class="c1"># reconstruct the covariance matrix</span>
            <span class="n">COV</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">sig</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">*</span><span class="n">ndims</span><span class="p">:</span>
                <span class="n">rho_list</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">ndims</span><span class="p">:]</span>
                <span class="c1"># add correlation estimates above...</span>
                <span class="n">COV</span><span class="p">[</span><span class="n">rho_init_ids</span><span class="p">]</span> <span class="o">=</span> <span class="n">COV</span><span class="p">[</span><span class="n">rho_init_ids</span><span class="p">]</span> <span class="o">*</span> <span class="n">rho_list</span>
                <span class="c1"># and below the main diagonal</span>
                <span class="n">COV</span><span class="p">[</span><span class="n">rho_init_ids2</span><span class="p">]</span> <span class="o">=</span> <span class="n">COV</span><span class="p">[</span><span class="n">rho_init_ids2</span><span class="p">]</span> <span class="o">*</span> <span class="n">rho_list</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">COV</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">sig</span><span class="p">)</span> <span class="o">*</span> <span class="n">rho</span>

        <span class="k">return</span> <span class="n">mu</span><span class="p">,</span> <span class="n">COV</span>

    <span class="c1"># create the negative log likelihood function for censored data from a</span>
    <span class="c1"># truncated multivariate normal distribution</span>
    <span class="k">def</span> <span class="nf">_neg_log_likelihood</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">enforce_bounds</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="n">verbose_NLL</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1">#if verbose_NLL: print()</span>
        <span class="n">params_to_show</span> <span class="o">=</span> <span class="n">params</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
        <span class="c1">#params_to_show = np.sum(params) # this is useful when there are many</span>

        <span class="c1"># first, check if the parameters are within the pre-defined bounds</span>
        <span class="k">if</span> <span class="n">enforce_bounds</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">params</span> <span class="o">&gt;</span> <span class="n">bnd_lower</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">params</span> <span class="o">&lt;</span> <span class="n">bnd_upper</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                <span class="c1"># if they are not, then return an infinite value to discourage the</span>
                <span class="c1"># optimization algorithm from going in that direction</span>
                <span class="k">if</span> <span class="n">verbose_NLL</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">params_to_show</span><span class="p">,</span> <span class="s1">&#39;out of bounds&#39;</span><span class="p">,</span> <span class="mf">1e10</span><span class="p">)</span>
                <span class="k">return</span> <span class="mf">1e10</span>

        <span class="c1"># return inf if there is nan in params:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">params</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">verbose_NLL</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">params_to_show</span><span class="p">,</span> <span class="s1">&#39;nan in params&#39;</span><span class="p">,</span> <span class="mf">1e10</span><span class="p">)</span>
            <span class="k">return</span> <span class="mf">1e10</span>

        <span class="c1"># reconstruct the mu and COV arrays from the parameters</span>
        <span class="n">mu</span><span class="p">,</span> <span class="n">COV</span> <span class="o">=</span> <span class="n">_get_mu_COV</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">rho</span><span class="p">)</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">ndims</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">ndims</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">ndims</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">pos_sem_def</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">COV</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mf">0.</span><span class="p">)</span>
            <span class="c1">#TODO: replace this with Cholesky decomposition check</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">pos_sem_def</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose_NLL</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">params_to_show</span><span class="p">,</span> <span class="s1">&#39;COV not pos sem def&#39;</span><span class="p">,</span> <span class="mf">1e10</span><span class="p">)</span>
                <span class="k">return</span> <span class="mf">1e10</span>

        <span class="c1"># calculate the probability density within the truncation limits</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tr_lower</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">tr_upper</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>

            <span class="n">alpha</span><span class="p">,</span> <span class="n">eps_alpha</span> <span class="o">=</span> <span class="n">mvn_orthotope_density</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">COV</span><span class="p">,</span>
                                                     <span class="n">tr_lower_adj</span><span class="p">,</span>
                                                     <span class="n">tr_upper_adj</span><span class="p">)</span>
            <span class="c1">#if verbose: print(tr_lower_adj, tr_upper_adj, mu, COV, alpha)</span>
            <span class="c1"># If the error in the alpha estimate is too large, then we are</span>
            <span class="c1"># beyond the applicability limits of the function used for</span>
            <span class="c1"># estimating alpha. Show a warning message and try to find another</span>
            <span class="c1"># solution by discouraging the optimization algorithm from going in</span>
            <span class="c1"># this direction.</span>
            <span class="k">if</span> <span class="n">alpha</span> <span class="o">&lt;=</span> <span class="mf">100.</span><span class="o">*</span><span class="n">eps_alpha</span><span class="p">:</span> <span class="c1">#i.e. max. error is limited at 1%</span>
                <span class="c1"># Note: throwing an error here would be too extreme, because it</span>
                <span class="c1"># would stop the analysis completely, while a solution might be</span>
                <span class="c1"># reached if we let the optimization algorithm converge to it.</span>
                <span class="k">if</span> <span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="ne">UserWarning</span><span class="p">(</span>
                        <span class="s1">&#39;The density of the joint probability distribution &#39;</span>
                        <span class="s1">&#39;within the truncation limits is too small and &#39;</span>
                        <span class="s1">&#39;cannot be estimated with sufficiently high &#39;</span>
                        <span class="s1">&#39;accuracy.&#39;</span>
                    <span class="p">))</span>
                    <span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="k">if</span> <span class="n">verbose_NLL</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">params_to_show</span><span class="p">,</span> <span class="s1">&#39;alpha estimate not applicable in truncs&#39;</span><span class="p">,</span> <span class="mf">1e10</span><span class="p">)</span>
                <span class="k">return</span> <span class="mf">1e10</span>

            <span class="c1"># If a lower limit was prescribed for alpha, it should also be</span>
            <span class="c1"># enforced here</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">alpha_lim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">&lt;</span> <span class="n">alpha_lim</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">msg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="ne">UserWarning</span><span class="p">(</span>
                        <span class="s1">&#39;The density of the joint probability distribution &#39;</span>
                        <span class="s1">&#39;within the truncation limits is less than the &#39;</span>
                        <span class="s1">&#39;prescribed minimum limit.&#39;</span>
                    <span class="p">))</span>
                    <span class="n">msg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="k">if</span> <span class="n">verbose_NLL</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">params_to_show</span><span class="p">,</span> <span class="s1">&#39;not enough prob mass within truncs&#39;</span><span class="p">,</span> <span class="mf">1e10</span><span class="p">)</span>
                <span class="k">return</span> <span class="mf">1e10</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">alpha</span><span class="p">,</span> <span class="n">eps_alpha</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span>

        <span class="c1"># calculate the likelihood for each available sample</span>
        <span class="n">likelihoods</span> <span class="o">=</span> <span class="n">multivariate_normal</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">samplesT</span><span class="p">,</span> <span class="n">mean</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">cov</span><span class="o">=</span><span class="n">COV</span><span class="p">,</span>
                                              <span class="n">allow_singular</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Zeros are a result of limited floating point precision. Replace them</span>
        <span class="c1"># with the smallest possible positive floating point number to</span>
        <span class="c1"># improve convergence.</span>
        <span class="n">likelihoods</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">likelihoods</span><span class="p">,</span> <span class="n">a_min</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nextafter</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">a_max</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="c1"># calculate the likelihoods corresponding to censored data (if any)</span>
        <span class="k">if</span> <span class="n">censored_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

            <span class="c1"># calculate the probability density within the detection limits</span>
            <span class="n">det_alpha</span><span class="p">,</span> <span class="n">eps_alpha</span> <span class="o">=</span> <span class="n">mvn_orthotope_density</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">COV</span><span class="p">,</span>
                                                         <span class="n">det_lower_adj</span><span class="p">,</span>
                                                         <span class="n">det_upper_adj</span><span class="p">)</span>
            <span class="c1"># Similarly to alpha above, make sure that det_alpha is estimated</span>
            <span class="c1"># with sufficient accuracy.</span>
            <span class="k">if</span> <span class="n">det_alpha</span> <span class="o">&lt;=</span> <span class="mf">100.</span><span class="o">*</span><span class="n">eps_alpha</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">msg</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                        <span class="s1">&#39;The density of the joint probability distribution &#39;</span>
                        <span class="s1">&#39;within the detection limits is too small and &#39;</span>
                        <span class="s1">&#39;cannot be estimated with sufficiently high &#39;</span>
                        <span class="s1">&#39;accuracy. &#39;</span>
                        <span class="s1">&#39;(alpha: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">det_alpha</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; eps: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">eps_alpha</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;)&#39;</span>
                    <span class="p">)</span>
                    <span class="n">msg</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="k">if</span> <span class="n">verbose_NLL</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">params_to_show</span><span class="p">,</span> <span class="s1">&#39;alpha estimate not applicable in dets&#39;</span><span class="p">,</span> <span class="mf">1e10</span><span class="p">)</span>
                <span class="k">return</span> <span class="mf">1e10</span>

            <span class="c1"># calculate the likelihood of censoring a sample</span>
            <span class="n">cen_likelihood</span> <span class="o">=</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">-</span> <span class="n">det_alpha</span><span class="p">)</span> <span class="o">/</span> <span class="n">alpha</span>

            <span class="c1"># make sure that the likelihood is a positive number</span>
            <span class="n">cen_likelihood</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">cen_likelihood</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nextafter</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">verbose_NLL</span> <span class="p">:</span>
                <span class="k">pass</span>
                <span class="c1">#print(&#39;dets and cen_liks&#39;)</span>
                <span class="c1">#print(det_lower, det_lower_adj)</span>
                <span class="c1">#print(det_upper, det_upper_adj)</span>
                <span class="c1">#print(det_alpha, cen_likelihood)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If the data is not censored, use 1.0 for cen_likelihood to get a</span>
            <span class="c1"># zero log-likelihood later. Note that although this is</span>
            <span class="c1"># theoretically not correct, it does not alter the solution and</span>
            <span class="c1"># it is numerically much more convenient than working around the</span>
            <span class="c1"># log of zero likelihood.</span>
            <span class="n">cen_likelihood</span> <span class="o">=</span> <span class="mf">1.</span>

        <span class="c1"># calculate the total negative log-likelihood</span>
        <span class="n">NLL</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">likelihoods</span><span class="p">))</span>                 <span class="c1"># from samples</span>
            <span class="o">-</span> <span class="n">nsamples</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>                    <span class="c1"># truncation influence</span>
            <span class="o">+</span> <span class="n">censored_count</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">cen_likelihood</span><span class="p">)</span>     <span class="c1"># censoring influence</span>
        <span class="p">)</span>

        <span class="c1"># normalize the likelihoods with the sample count</span>
        <span class="n">NLL</span> <span class="o">=</span> <span class="n">NLL</span><span class="o">/</span><span class="n">nsamples</span>
        <span class="c1">#print(mu[-4:], NLL)</span>
        <span class="c1">#print(np.sqrt(np.diagonal(COV))[-4:],NLL)</span>

        <span class="k">if</span> <span class="n">verbose_NLL</span><span class="p">:</span>
          <span class="k">pass</span>
          <span class="c1">#print(params_to_show, &#39;all good&#39;, NLL)</span>
        <span class="k">return</span> <span class="n">NLL</span>

    <span class="c1"># initialize the message flags</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">_neg_log_likelihood</span><span class="p">(</span><span class="n">inits</span><span class="p">,</span> <span class="n">rho_init</span><span class="p">))</span>

    <span class="c1"># perturbation</span>
    <span class="c1">#inits[:ndims] = inits[:ndims]+np.random.uniform(low=-0.5, high=0.5, size=ndims)</span>
    <span class="c1">#inits[ndims:2*ndims] += 0.5</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">t_0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="c1"># minimize the negative log-likelihood function</span>
    <span class="c1">#out = minimize(_neg_log_likelihood, inits, args=(rho_init, True),</span>
    <span class="c1">#               bounds=bounds, method=&#39;TNC&#39;)</span>

    <span class="c1"># Global optimization with a more sophisticated method is only</span>
    <span class="c1"># reasonable if we have a sufficiently large number of samples.</span>
    <span class="c1"># Considering the size of the covariance matrix, we are looking for at least</span>
    <span class="c1"># ndims^2 samples to use differential evolution.</span>
    <span class="k">if</span> <span class="n">nsamples</span> <span class="o">&gt;</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">ndims</span><span class="o">**</span><span class="mf">2.0</span><span class="p">:</span>

        <span class="n">out_d</span> <span class="o">=</span> <span class="n">differential_evolution</span><span class="p">(</span><span class="n">_neg_log_likelihood</span><span class="p">,</span> <span class="n">mu_bounds</span> <span class="o">+</span> <span class="n">sig_bounds</span><span class="p">,</span>
                                       <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">rho_init</span><span class="p">,),</span>
                                       <span class="n">maxiter</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span>
                                       <span class="n">polish</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">mu_sig_vals</span> <span class="o">=</span> <span class="n">out_d</span><span class="o">.</span><span class="n">x</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">out_d</span><span class="p">)</span>
            <span class="c1"># print(out.fun, out.nfev, out.nit, out.message, out.x)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;runtime: &#39;</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t_0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mu_sig_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">inits</span><span class="p">[:</span><span class="mi">2</span><span class="o">*</span><span class="n">ndims</span><span class="p">])</span>

    <span class="c1"># Minimize the negative log-likelihood function using the adaptive</span>
    <span class="c1"># Adaptive Nelder-Mead algorithm (Gao and Han, 2012)</span>
    <span class="k">if</span> <span class="n">nsamples</span> <span class="o">&gt;</span> <span class="n">ndims</span><span class="p">:</span>
        <span class="n">out_m</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">_neg_log_likelihood</span><span class="p">,</span>
                         <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">mu_sig_vals</span><span class="p">,</span> <span class="n">inits</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">ndims</span><span class="p">:]]),</span>
                       <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">rho_init</span><span class="p">,</span><span class="kc">True</span><span class="p">),</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;Nelder-Mead&#39;</span><span class="p">,</span>
                       <span class="n">options</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">maxfev</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="mi">1000</span><span class="o">*</span><span class="n">ndims</span><span class="p">,</span> <span class="mi">10000</span><span class="p">),</span>
                                    <span class="n">xatol</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span>
                                    <span class="n">fatol</span> <span class="o">=</span> <span class="mf">1e-10</span><span class="p">,</span>
                                    <span class="n">adaptive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                       <span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">out_m</span><span class="p">)</span>
            <span class="c1">#print(out.fun, out.nfev, out.nit, out.message, out.x)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;runtime: &#39;</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t_0</span><span class="p">)</span>

        <span class="c1"># reconstruct the mu and COV arrays from the solutions and return them</span>
        <span class="n">mu</span><span class="p">,</span> <span class="n">COV</span> <span class="o">=</span> <span class="n">_get_mu_COV</span><span class="p">(</span><span class="n">out_m</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rho_init</span><span class="p">,</span> <span class="n">unbiased</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mu</span><span class="p">,</span> <span class="n">COV</span> <span class="o">=</span> <span class="n">_get_mu_COV</span><span class="p">(</span><span class="n">mu_sig_vals</span><span class="p">,</span> <span class="n">rho_init</span><span class="p">,</span> <span class="n">unbiased</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ndims</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;mu vs mu_init&#39;</span><span class="p">)</span>
            <span class="n">show_matrix</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span><span class="n">mu_init</span><span class="p">)))</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="n">COV</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;sig vs sig_init&#39;</span><span class="p">)</span>
            <span class="n">show_matrix</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span><span class="n">sig_init</span><span class="p">)))</span>
            <span class="n">rho</span> <span class="o">=</span> <span class="p">(</span><span class="n">COV</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span><span class="n">sig</span><span class="p">))[</span><span class="o">-</span><span class="mi">8</span><span class="p">:,</span><span class="o">-</span><span class="mi">8</span><span class="p">:]</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;rho&#39;</span><span class="p">)</span>
            <span class="n">show_matrix</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;rho_init&#39;</span><span class="p">)</span>
            <span class="n">show_matrix</span><span class="p">(</span><span class="n">rho_init</span><span class="p">[</span><span class="o">-</span><span class="mi">8</span><span class="p">:,</span><span class="o">-</span><span class="mi">8</span><span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;mu vs mu_init&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">mu_init</span><span class="p">)</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">COV</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;sig vs sig_init&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">sig_init</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">ndims</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="n">COV</span><span class="p">))</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="p">(</span><span class="n">COV</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">sig</span><span class="p">))</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">sig</span> <span class="o">*</span> <span class="n">sig_hat</span>
        <span class="n">COV</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">sig</span><span class="p">)</span> <span class="o">*</span> <span class="n">rho</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">COV</span><span class="p">)</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">sig</span><span class="o">*</span><span class="n">sig_hat</span>
        <span class="n">COV</span> <span class="o">=</span> <span class="n">sig</span><span class="o">**</span><span class="mf">2.0</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">mu_hat</span> <span class="o">+</span> <span class="n">mu</span> <span class="o">*</span> <span class="n">sig_hat</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">final values:&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">COV</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">mu</span><span class="p">,</span> <span class="n">COV</span></div>


<div class="viewcode-block" id="RandomVariable"><a class="viewcode-back" href="../../source/pelicun.uq.html#pelicun.uq.RandomVariable">[docs]</a><span class="k">class</span> <span class="nc">RandomVariable</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Characterizes a Random Variable (RV) that represents a source of</span>
<span class="sd">    uncertainty in the calculation.</span>

<span class="sd">    The uncertainty can be described either through raw data or through a</span>
<span class="sd">    pre-defined distribution function. When using raw data, provide potentially</span>
<span class="sd">    correlated raw samples in a 2 dimensional array. If the data is left or</span>
<span class="sd">    right censored in any number of its dimensions, provide the list of</span>
<span class="sd">    detection limits and the number of censored samples. No other information</span>
<span class="sd">    is needed to define the object from raw data. Then, either resample the raw</span>
<span class="sd">    data, or fit a prescribed distribution to the samples and sample from that</span>
<span class="sd">    distribution later.</span>

<span class="sd">    Alternatively, one can choose to prescribe a distribution type and its</span>
<span class="sd">    parameters and sample from that distribution later.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ID: int</span>
<span class="sd">    dimension_tags: str array</span>
<span class="sd">        A series of strings that identify the stochastic model parameters that</span>
<span class="sd">        correspond to each dimension of the random variable. When the RV is one</span>
<span class="sd">        dimensional, the dim_tag is a single string. In multi-dimensional</span>
<span class="sd">        cases, the order of strings shall match the order of elements provided</span>
<span class="sd">        as other inputs.</span>
<span class="sd">    raw_data: float scalar or ndarray, optional, default: None</span>
<span class="sd">        Samples of an uncertain variable. The samples can describe a</span>
<span class="sd">        multi-dimensional random variable if they are arranged in a 2D ndarray.</span>
<span class="sd">    detection_limits: float ndarray, optional, default: None</span>
<span class="sd">        Defines the limits for censored data. The limits need to be defined in</span>
<span class="sd">        a 2D ndarray that is structured as two vectors with N elements. The</span>
<span class="sd">        vectors collect left and right limits for the N dimensions. If the data</span>
<span class="sd">        is not censored in a particular direction, assign None to that position</span>
<span class="sd">        of the ndarray. Replacing one of the vectors with None will assign no</span>
<span class="sd">        censoring to all dimensions in that direction. The default value</span>
<span class="sd">        corresponds to no censoring in either dimension.</span>
<span class="sd">    censored_count: int, optional, default: None</span>
<span class="sd">        The number of censored samples that are beyond the detection limits.</span>
<span class="sd">        All samples outside the detection limits are aggregated into one set.</span>
<span class="sd">        This works the same way in one and in multiple dimensions. Prescription</span>
<span class="sd">        of censored sample counts for sub-regions of the input space outside</span>
<span class="sd">        the detection limits is not yet supported. If such an approach is</span>
<span class="sd">        desired, the censored raw data shall be used to fit a distribution in a</span>
<span class="sd">        pre-processing step and the fitted distribution can be specified for</span>
<span class="sd">        this random variable.</span>
<span class="sd">    distribution_kind: {&#39;normal&#39;, &#39;lognormal&#39;, &#39;multinomial&#39;}, optional, default: None</span>
<span class="sd">        Defines the type of probability distribution when raw data is not</span>
<span class="sd">        provided, but the distribution is directly specified. When part of the</span>
<span class="sd">        data is normal in log space, while the other part is normal in linear</span>
<span class="sd">        space, define a list of distribution tags such as [&#39;normal&#39;, &#39;normal&#39;,</span>
<span class="sd">        &#39;lognormal&#39;]. Make sure that the covariance matrix is based on log</span>
<span class="sd">        transformed data for the lognormally distributed variables! Mixing</span>
<span class="sd">        normal distributions with multinomials is not supported.</span>
<span class="sd">    theta: float scalar or ndarray, optional, default: None</span>
<span class="sd">        Median of the probability distribution. A vector of medians is expected</span>
<span class="sd">        in a multi-dimensional case.</span>
<span class="sd">    COV: float scalar or 2D ndarray, optional, default: None</span>
<span class="sd">        Covariance matrix of the random variable. In a multi-dimensional case</span>
<span class="sd">        this parameter has to be a 2D square ndarray, and the number of its</span>
<span class="sd">        rows has to be equal to the number of elements in the supplied theta</span>
<span class="sd">        vector. In a one-dimensional case, a single value is expected that</span>
<span class="sd">        equals the variance (not the standard deviation!) of the distribution.</span>
<span class="sd">        The COV for lognormal variables is assumed to be specified in</span>
<span class="sd">        logarithmic space.</span>
<span class="sd">    corr_ref: {&#39;pre&#39;, &#39;post&#39;}, optional, default: &#39;pre&#39;</span>
<span class="sd">        Determines whether the correlations prescribed by the covariance matrix</span>
<span class="sd">        refer to the distribution functions before or after truncation. The</span>
<span class="sd">        default &#39;pre&#39; setting assumes that pre-truncation correlations are</span>
<span class="sd">        prescribed and creates a multivariate normal distribution using the</span>
<span class="sd">        COV matrix. That distribution is truncated according to the prescribed</span>
<span class="sd">        truncation limits. The other option assumes that post-truncation</span>
<span class="sd">        correlations are prescribed. The post-truncation distribution</span>
<span class="sd">        is not multivariate normal in general. Currently we use a Gaussian</span>
<span class="sd">        copula to describe the dependence between the truncated variables.</span>
<span class="sd">        Similarly to other characteristics, the `corr_ref` can be defined as a</span>
<span class="sd">        single string, or a vector of strings. The former assigns the same</span>
<span class="sd">        option to all dimensions, while the latter allows for more flexible</span>
<span class="sd">        assignment by setting the corr_ref for each dimension individually.</span>
<span class="sd">    p_set: float vector, optional, default: None</span>
<span class="sd">        Probabilities of a finite set of events described by a multinomial</span>
<span class="sd">        distribution. The RV will have binomial distribution if only one</span>
<span class="sd">        element is provided in this vector. The number of events equals the</span>
<span class="sd">        number of vector elements if their probabilities sum up to 1.0. If the</span>
<span class="sd">        sum is less than 1.0, then an additional event is assumed with the</span>
<span class="sd">        remaining probability of occurrence assigned to it. The sum of</span>
<span class="sd">        event probabilities shall never be more than 1.0.</span>
<span class="sd">    truncation_limits: float ndarray, optional, default: None</span>
<span class="sd">        Defines the limits for truncated distributions. The limits need to be</span>
<span class="sd">        defined in a 2D ndarray that is structured as two vectors with N</span>
<span class="sd">        elements. The vectors collect left and right limits for the N</span>
<span class="sd">        dimensions. If the distribution is not truncated in a particular</span>
<span class="sd">        direction, assign None to that position of the ndarray. Replacing one</span>
<span class="sd">        of the vectors with None will assign no truncation to all dimensions</span>
<span class="sd">        in that direction. The default value corresponds to no truncation in</span>
<span class="sd">        either dimension.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ID</span><span class="p">,</span> <span class="n">dimension_tags</span><span class="p">,</span>
                 <span class="n">raw_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">detection_limits</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">censored_count</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">distribution_kind</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">theta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">COV</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">corr_ref</span><span class="o">=</span><span class="s1">&#39;pre&#39;</span><span class="p">,</span> <span class="n">p_set</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">truncation_limits</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ID</span> <span class="o">=</span> <span class="n">ID</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_dimension_tags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">dimension_tags</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">raw_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">raw_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">raw_data</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">raw_data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ndim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ncount</span> <span class="o">=</span> <span class="n">raw_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ndim</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ncount</span> <span class="o">=</span> <span class="n">raw_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raw_data</span> <span class="o">=</span> <span class="n">raw_data</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_detection_limits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_limits</span><span class="p">(</span><span class="n">detection_limits</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_censored_count</span> <span class="o">=</span> <span class="n">censored_count</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_detection_limits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_limits</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_censored_count</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">distribution_kind</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">distribution_kind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">distribution_kind</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_distribution_kind</span> <span class="o">=</span> <span class="n">distribution_kind</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distribution_kind</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">theta</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">theta</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_ndim</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_ndim</span> <span class="o">=</span> <span class="n">theta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span> <span class="o">=</span> <span class="n">theta</span>

            <span class="k">if</span> <span class="n">COV</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">COV</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">COV</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_COV</span> <span class="o">=</span> <span class="n">COV</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_corr_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">corr_ref</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">p_set</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">p_set</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">p_set</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">p_set</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1.</span><span class="p">:</span>
                    <span class="n">p_set</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p_set</span><span class="p">,</span> <span class="mf">1.</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">p_set</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ndim</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_p_set</span> <span class="o">=</span> <span class="n">p_set</span>

            <span class="n">tr_limits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_limits</span><span class="p">(</span><span class="n">truncation_limits</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tr_limits_pre</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tr_limits_post</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">_create_pre_post_tr_limits</span><span class="p">(</span><span class="n">tr_limits</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_COV</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_corr_ref</span> <span class="o">=</span> <span class="n">corr_ref</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_p_set</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tr_limits_pre</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_limits</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tr_limits_post</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tr_limits_pre</span><span class="p">)</span>

        <span class="c1"># perform some basic checks to make sure that the provided data will be</span>
        <span class="c1"># sufficient to define a random variable</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="c1"># if the RV is defined by providing distribution data...</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distribution_kind</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Either raw samples or a distribution needs to be defined &quot;</span>
                    <span class="s2">&quot;for a random variable.&quot;</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_distribution_kind</span><span class="o">.</span><span class="n">shape</span><span class="o">!=</span><span class="p">())</span>
                <span class="ow">or</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_distribution_kind</span><span class="o">.</span><span class="n">shape</span><span class="o">==</span><span class="p">())</span>
                    <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_distribution_kind</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;normal&#39;</span><span class="p">,</span> <span class="s1">&#39;lognormal&#39;</span><span class="p">]))):</span>
                <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_theta</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_COV</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Normal and lognormal distributions require theta and &quot;</span>
                        <span class="s2">&quot;COV parameters.&quot;</span>
                    <span class="p">)</span>

            <span class="k">if</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_distribution_kind</span><span class="o">.</span><span class="n">shape</span><span class="o">==</span><span class="p">())</span>
                <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_distribution_kind</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;multinomial&#39;</span><span class="p">])</span>
                <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_p_set</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Multinomial distributions require a set of p values as &quot;</span>
                    <span class="s2">&quot;parameters.&quot;</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># if the RV is defined through raw samples</span>
            <span class="k">if</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_detection_limits</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">!=</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_censored_count</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Definition of censored data requires information about &quot;</span>
                    <span class="s2">&quot;the detection limits and the number of censored samples.&quot;</span>
                <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_convert_limits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">limits</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert None values to infinites in truncation and detection limits.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_ndim&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">limits</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="c1"># convert single-element limits array into a nested</span>
            <span class="c1"># structure that is easier to work with</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
                <span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">limits</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
                <span class="n">limits</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">limits</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">]</span>

            <span class="c1"># assign a vector of None in place of a single None value</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                <span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ndim</span><span class="p">)]</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">limits</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">limits</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                <span class="n">limits</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ndim</span><span class="p">)]</span>

            <span class="c1"># replace None values with infinite limits</span>
            <span class="k">for</span> <span class="n">l_i</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">l</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">l_i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="k">for</span> <span class="n">l_i</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">limits</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">l</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">limits</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">l_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>

            <span class="n">limits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">limits</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">limits</span>

    <span class="k">def</span> <span class="nf">_create_pre_post_tr_limits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">truncation_limits</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Separates the truncation limits into two groups: (i) `pre` truncation</span>
<span class="sd">        limits apply to distributions where the correlations refer to the</span>
<span class="sd">        joint distribution before truncation; (ii) `post` truncation limits</span>
<span class="sd">        apply to distributions after truncation. Truncation in the latter case</span>
<span class="sd">        is applied differently, hence the need to separate the two types of</span>
<span class="sd">        modifications.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">truncation_limits</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_ndim&#39;</span><span class="p">)):</span>
            <span class="n">tr_lower</span><span class="p">,</span> <span class="n">tr_upper</span> <span class="o">=</span> <span class="n">truncation_limits</span>
            <span class="n">CR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_corr_ref</span>

            <span class="c1"># a single value or identical values means one setting</span>
            <span class="c1"># applies to all dims</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">CR</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">CR</span><span class="p">)</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">CR</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">CR</span> <span class="o">=</span> <span class="n">CR</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">CR</span> <span class="o">==</span> <span class="s1">&#39;pre&#39;</span><span class="p">:</span>
                    <span class="n">trl_pre</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">truncation_limits</span><span class="p">)</span>
                    <span class="n">trl_post</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">elif</span> <span class="n">CR</span> <span class="o">==</span> <span class="s1">&#39;post&#39;</span><span class="p">:</span>
                    <span class="n">trl_pre</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="n">trl_post</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">truncation_limits</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># otherwise assign the appropriate limits to each dim</span>
                <span class="n">tr_lower_pre</span><span class="p">,</span> <span class="n">tr_lower_post</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_ndim</span><span class="p">))</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                <span class="n">tr_upper_pre</span><span class="p">,</span> <span class="n">tr_upper_post</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_ndim</span><span class="p">))</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                <span class="n">tr_lower_pre</span><span class="p">[</span><span class="n">CR</span> <span class="o">==</span> <span class="s1">&#39;pre&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tr_lower</span><span class="p">[</span><span class="n">CR</span> <span class="o">==</span> <span class="s1">&#39;pre&#39;</span><span class="p">]</span>
                <span class="n">tr_upper_pre</span><span class="p">[</span><span class="n">CR</span> <span class="o">==</span> <span class="s1">&#39;pre&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tr_upper</span><span class="p">[</span><span class="n">CR</span> <span class="o">==</span> <span class="s1">&#39;pre&#39;</span><span class="p">]</span>
                <span class="n">tr_lower_post</span><span class="p">[</span><span class="n">CR</span> <span class="o">==</span> <span class="s1">&#39;post&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tr_lower</span><span class="p">[</span><span class="n">CR</span> <span class="o">==</span> <span class="s1">&#39;post&#39;</span><span class="p">]</span>
                <span class="n">tr_upper_post</span><span class="p">[</span><span class="n">CR</span> <span class="o">==</span> <span class="s1">&#39;post&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tr_upper</span><span class="p">[</span><span class="n">CR</span> <span class="o">==</span> <span class="s1">&#39;post&#39;</span><span class="p">]</span>

                <span class="n">trl_pre</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">tr_lower_pre</span><span class="p">,</span> <span class="n">tr_upper_pre</span><span class="p">])</span>
                <span class="n">trl_post</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">tr_lower_post</span><span class="p">,</span> <span class="n">tr_upper_post</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">trl_pre</span><span class="p">,</span> <span class="n">trl_post</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">trl_pre</span><span class="p">,</span> <span class="n">trl_post</span>

    <span class="k">def</span> <span class="nf">_move_to_log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raw_data</span><span class="p">,</span> <span class="n">distribution_list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert data to log space for the lognormal variables.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">distribution_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">raw_data</span>
        <span class="k">elif</span> <span class="n">distribution_list</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">():</span>
            <span class="c1"># meaning identical distribution families</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">raw_data</span>
            <span class="k">if</span> <span class="n">distribution_list</span> <span class="o">==</span> <span class="s1">&#39;lognormal&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">raw_data</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># this can gracefully handle non-positive limits for</span>
                    <span class="c1"># lognormal distributions</span>
                    <span class="n">min_float</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nextafter</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">raw_data</span><span class="p">,</span> <span class="n">a_min</span><span class="o">=</span><span class="n">min_float</span><span class="p">,</span>
                                          <span class="n">a_max</span><span class="o">=</span><span class="kc">None</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">():</span>
                        <span class="k">if</span> <span class="n">data</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">min_float</span><span class="p">):</span>
                            <span class="n">data</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                    <span class="c1"># Although the following code would help with other</span>
                    <span class="c1"># incorrect data, it might also hide such problems and</span>
                    <span class="c1"># the current implementation does not need it, so it</span>
                    <span class="c1"># is disabled for now.</span>
                    <span class="c1">#else:</span>
                    <span class="c1">#    data[data==np.log(min_float)] = -np.inf</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">raw_data</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">dk</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">distribution_list</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">dk</span> <span class="o">==</span> <span class="s1">&#39;lognormal&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">dim</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mf">0.</span><span class="p">:</span>
                        <span class="n">data</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">dim</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># this can gracefully handle non-positive limits for</span>
                        <span class="c1"># lognormal distributions</span>
                        <span class="n">min_float</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nextafter</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                        <span class="n">data</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">dim</span><span class="p">],</span> <span class="n">a_min</span><span class="o">=</span><span class="n">min_float</span><span class="p">,</span>
                                                   <span class="n">a_max</span><span class="o">=</span><span class="kc">None</span><span class="p">))</span>
                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">dim</span><span class="p">])</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">():</span>
                            <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">min_float</span><span class="p">):</span>
                                <span class="n">data</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                        <span class="c1">#else:</span>
                        <span class="c1">#    data[dim][data[dim]==np.log(min_float)] = -np.inf</span>

        <span class="k">return</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">_return_from_log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raw_data</span><span class="p">,</span> <span class="n">distribution_list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert data back to linear space for the lognormal variables.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">distribution_list</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">():</span>
            <span class="c1"># meaning identical distribution families</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">raw_data</span>
            <span class="k">if</span> <span class="n">distribution_list</span> <span class="o">==</span> <span class="s1">&#39;lognormal&#39;</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">raw_data</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">distribution_list</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,):</span>
            <span class="k">if</span> <span class="n">distribution_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;lognormal&#39;</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">raw_data</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">raw_data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">raw_data</span>
            <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">dk</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">distribution_list</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">dk</span> <span class="o">==</span> <span class="s1">&#39;lognormal&#39;</span><span class="p">:</span>
                    <span class="n">data</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">dim</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">data</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">distribution_kind</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the assigned probability distribution family.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distribution_kind</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">theta</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the median value(s) of the probability distribution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The median of the probability distribution of this random &quot;</span>
                <span class="s2">&quot;variable is not yet specified.&quot;</span>
            <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mu</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the mean value(s) of the probability distribution. Note that</span>
<span class="sd">        the mean value is in log space for lognormal distributions.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_move_to_log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distribution_kind</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">COV</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the covariance matrix of the probability distribution. Note that</span>
<span class="sd">        the covariances are in log space for lognormal distributions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_COV</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_COV</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The covariance matrix of the probability distribution of &quot;</span>
                <span class="s2">&quot;this random variable is not yet specified.&quot;</span>
            <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">corr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the correlation matrix of the probability distribution. Note that</span>
<span class="sd">        correlation coefficient correspond to the joint distribution in log</span>
<span class="sd">        space for lognormal distributions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_COV</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_COV</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sig</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The correlation matrix of the probability distribution of &quot;</span>
                <span class="s2">&quot;this random variable is not yet specified.&quot;</span>
            <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">var</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the variance vector of the probability distribution. Note that</span>
<span class="sd">        the variances are in log space for lognormal distributions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_COV</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_COV</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The covariance matrix of the probability distribution of &quot;</span>
                <span class="s2">&quot;this random variable is not yet specified.&quot;</span>
            <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sig</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the standard deviation vector of the probability distribution.</span>
<span class="sd">        Note that the standard deviations are in log space for lognormal</span>
<span class="sd">        distributions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_COV</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">var</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The covariance matrix of the probability distribution of &quot;</span>
                <span class="s2">&quot;this random variable is not yet specified.&quot;</span>
            <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dimension_tags</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the tags corresponding to the dimensions of the variable.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># this is very simple for now</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dimension_tags</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">detection_limits</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the detection limits corresponding to the raw data in linear</span>
<span class="sd">        space.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># this is very simple for now</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_detection_limits</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">det_lower</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the lower detection limit(s) corresponding to the raw data in</span>
<span class="sd">        either linear or log space according to the distribution.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_detection_limits</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_move_to_log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_detection_limits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">_distribution_kind</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">det_upper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the upper detection limit(s) corresponding to the raw data in</span>
<span class="sd">        either linear or log space according to the distribution.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_detection_limits</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_move_to_log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_detection_limits</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">_distribution_kind</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tr_limits_pre</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the `pre` truncation limits of the probability distribution in</span>
<span class="sd">        linear space.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># this is very simple for now</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tr_limits_pre</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tr_limits_post</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the `post` truncation limits of the probability distribution in</span>
<span class="sd">        linear space.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># this is very simple for now</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tr_limits_post</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tr_lower_pre</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the lower `pre` truncation limit(s) corresponding to the</span>
<span class="sd">        distribution in either linear or log space according to the</span>
<span class="sd">        distribution.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tr_limits_pre</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_move_to_log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tr_limits_pre</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">_distribution_kind</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tr_upper_pre</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the upper `pre` truncation limit(s) corresponding to the</span>
<span class="sd">        distribution in either linear or log space according to the</span>
<span class="sd">        distribution.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tr_limits_pre</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_move_to_log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tr_limits_pre</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">_distribution_kind</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tr_lower_post</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the lower `post` truncation limit(s) corresponding to the</span>
<span class="sd">        distribution in either linear or log space according to the</span>
<span class="sd">        distribution.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tr_limits_post</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_move_to_log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tr_limits_post</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">_distribution_kind</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tr_upper_post</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the upper `post` truncation limit(s) corresponding to the</span>
<span class="sd">        distribution in either linear or log space according to the</span>
<span class="sd">        distribution.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tr_limits_post</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_move_to_log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tr_limits_post</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">_distribution_kind</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">censored_count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of samples beyond the detection limits.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_censored_count</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_censored_count</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">samples</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the pre-generated samples from the distribution.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_samples&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_samples</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">raw</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the pre-assigned raw data.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_raw_data&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw_data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

<div class="viewcode-block" id="RandomVariable.fit_distribution"><a class="viewcode-back" href="../../source/pelicun.uq.html#pelicun.uq.RandomVariable.fit_distribution">[docs]</a>    <span class="k">def</span> <span class="nf">fit_distribution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distribution_kind</span><span class="p">,</span> <span class="n">truncation_limits</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Estimate the parameters of a probability distribution from raw data.</span>

<span class="sd">        Parameter estimates are calculated using maximum likelihood estimation.</span>
<span class="sd">        If the data spans multiple dimensions, the estimates will also describe</span>
<span class="sd">        a multi-dimensional distribution automatically. Data censoring is also</span>
<span class="sd">        automatically taken into consideration following the detection limits</span>
<span class="sd">        specified previously for the random variable. Truncated target</span>
<span class="sd">        distributions can be specified through the truncation limits. The</span>
<span class="sd">        specified truncation limits are applied after the correlations are set.</span>
<span class="sd">        In other words, the corr_ref proprety of the RV is set to &#39;pre&#39; when</span>
<span class="sd">        fitting a distribution.</span>

<span class="sd">        Besides returning the parameter estimates, their values are also stored</span>
<span class="sd">        as theta and COV attributes of the RandomVariable object for future</span>
<span class="sd">        use.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        distribution_kind: {&#39;normal&#39;, &#39;lognormal&#39;} or a list of those</span>
<span class="sd">            Specifies the type of the probability distribution that is fit to</span>
<span class="sd">            the raw data. When part of the data is normal in log space, while</span>
<span class="sd">            the other part is normal in linear space, define a list of</span>
<span class="sd">            distribution tags such as [&#39;normal&#39;, &#39;normal&#39;, &#39;lognormal&#39;].</span>
<span class="sd">        truncation_limits: float ndarray, optional, default: None</span>
<span class="sd">            Defines the limits for truncated distributions. The limits need to</span>
<span class="sd">            be defined in a 2D ndarray that is structured as two vectors with N</span>
<span class="sd">            elements. The vectors collect left and right limits for the N</span>
<span class="sd">            dimensions. If the distribution is not truncated in a particular</span>
<span class="sd">            direction, assign None to that position of the ndarray. Replacing</span>
<span class="sd">            one of the vectors with None will assign no truncation to all</span>
<span class="sd">            dimensions in that direction. The default value corresponds to no</span>
<span class="sd">            truncation in either dimension.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        theta: float scalar or ndarray</span>
<span class="sd">            Median of the probability distribution. A vector of medians is</span>
<span class="sd">            returned in a multi-dimensional case.</span>
<span class="sd">        COV: float scalar or 2D ndarray</span>
<span class="sd">            Covariance matrix of the probability distribution. A 2D square</span>
<span class="sd">            ndarray is returned in a multi-dimensional case.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># lognormal distribution parameters are estimated by fitting a normal</span>
        <span class="c1"># distribution to the data in log space</span>
        <span class="n">distribution_kind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">distribution_kind</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_move_to_log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_raw_data</span><span class="p">,</span> <span class="n">distribution_kind</span><span class="p">)</span>

        <span class="c1"># prepare the information on truncation</span>
        <span class="k">if</span> <span class="n">truncation_limits</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tr_lower</span><span class="p">,</span> <span class="n">tr_upper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_limits</span><span class="p">(</span><span class="n">truncation_limits</span><span class="p">)</span>
            <span class="n">tr_lower</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_move_to_log</span><span class="p">(</span><span class="n">tr_lower</span><span class="p">,</span> <span class="n">distribution_kind</span><span class="p">)</span>
            <span class="n">tr_upper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_move_to_log</span><span class="p">(</span><span class="n">tr_upper</span><span class="p">,</span> <span class="n">distribution_kind</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tr_lower</span><span class="p">,</span> <span class="n">tr_upper</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

        <span class="c1"># convert the detection limits to log if needed</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">detection_limits</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">det_lower</span><span class="p">,</span> <span class="n">det_upper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">detection_limits</span>
            <span class="n">det_lower</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_move_to_log</span><span class="p">(</span><span class="n">det_lower</span><span class="p">,</span> <span class="n">distribution_kind</span><span class="p">)</span>
            <span class="n">det_upper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_move_to_log</span><span class="p">(</span><span class="n">det_upper</span><span class="p">,</span> <span class="n">distribution_kind</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">det_lower</span><span class="p">,</span> <span class="n">det_upper</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

        <span class="c1"># perform the parameter estimation</span>
        <span class="n">mu</span><span class="p">,</span> <span class="n">COV</span> <span class="o">=</span> <span class="n">tmvn_MLE</span><span class="p">(</span><span class="n">data</span><span class="p">,</span>
                           <span class="n">tr_lower</span> <span class="o">=</span> <span class="n">tr_lower</span><span class="p">,</span> <span class="n">tr_upper</span><span class="o">=</span><span class="n">tr_upper</span><span class="p">,</span>
                           <span class="n">censored_count</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">censored_count</span><span class="p">,</span>
                           <span class="n">det_lower</span><span class="o">=</span><span class="n">det_lower</span><span class="p">,</span> <span class="n">det_upper</span><span class="o">=</span><span class="n">det_upper</span><span class="p">)</span>

        <span class="c1"># convert mu to theta</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_return_from_log</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">distribution_kind</span><span class="p">)</span>

        <span class="c1"># store and return the parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span> <span class="o">=</span> <span class="n">theta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_COV</span> <span class="o">=</span> <span class="n">COV</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_corr_ref</span> <span class="o">=</span> <span class="s1">&#39;pre&#39;</span>
        <span class="c1">#TODO: implement &#39;post&#39; corr_ref as an option for fitting</span>

        <span class="c1"># store the distribution properties</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_distribution_kind</span> <span class="o">=</span> <span class="n">distribution_kind</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tr_limits_pre</span> <span class="o">=</span> <span class="n">truncation_limits</span>

        <span class="k">return</span> <span class="n">theta</span><span class="p">,</span> <span class="n">COV</span></div>

<div class="viewcode-block" id="RandomVariable.sample_distribution"><a class="viewcode-back" href="../../source/pelicun.uq.html#pelicun.uq.RandomVariable.sample_distribution">[docs]</a>    <span class="k">def</span> <span class="nf">sample_distribution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_size</span><span class="p">,</span> <span class="n">preserve_order</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sample the probability distribution assigned to the random variable.</span>

<span class="sd">        Normal distributions (including truncated and/or multivariate normal</span>
<span class="sd">        and lognormal) are sampled using the tmvn_rvs() method in this module.</span>
<span class="sd">        If post-truncation correlations are set for a dimension, the</span>
<span class="sd">        corresponding truncations are enforced after sampling by first applying</span>
<span class="sd">        probability integral transformation to transform samples from the</span>
<span class="sd">        non-truncated normal to standard uniform distribution, and then</span>
<span class="sd">        applying inverse probability integral transformation to transform the</span>
<span class="sd">        samples from standard uniform to the desired truncated normal</span>
<span class="sd">        distribution. Multinomial distributions are sampled using the</span>
<span class="sd">        multinomial method in scipy. The samples are returned and also stored</span>
<span class="sd">        in the `sample` attribute of the RV.</span>

<span class="sd">        If the random variable is defined by raw data only, we sample from the</span>
<span class="sd">        raw data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sample_size: int</span>
<span class="sd">            Number of samples requested.</span>
<span class="sd">        preserve_order: bool, default: False</span>
<span class="sd">            Influences sampling from raw data. If True, the samples are copies</span>
<span class="sd">            of the first n rows of the raw data where n is the sample_size. This</span>
<span class="sd">            only works for sample_size &lt;= raw data size. If False, the samples</span>
<span class="sd">            are drawn from the raw data pool with replacement.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        samples: DataFrame</span>
<span class="sd">            Samples generated from the distribution. Columns correspond to the</span>
<span class="sd">            dimension tags that identify the variables.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distribution_kind</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_distribution_kind</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">())</span> <span class="ow">and</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_distribution_kind</span> <span class="o">==</span> <span class="s1">&#39;multinomial&#39;</span><span class="p">)):</span>

                <span class="c1"># sampling the multinomial distribution</span>
                <span class="n">samples</span> <span class="o">=</span> <span class="n">multinomial</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_p_set</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">sample_size</span><span class="p">)</span>

                <span class="c1"># convert the 2D sample array into a vector of integers</span>
                <span class="n">outcomes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_p_set</span><span class="p">))])</span>
                <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">outcomes</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                <span class="n">samples</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">samples</span><span class="p">),</span>
                                       <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_dimension_tags</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># sampling the truncated multivariate normal distribution</span>
                <span class="n">raw_samples</span> <span class="o">=</span> <span class="n">tmvn_rvs</span><span class="p">(</span><span class="n">mu</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">,</span> <span class="n">COV</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">COV</span><span class="p">,</span>
                                       <span class="n">lower</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tr_lower_pre</span><span class="p">,</span>
                                       <span class="n">upper</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tr_upper_pre</span><span class="p">,</span>
                                       <span class="n">size</span><span class="o">=</span><span class="n">sample_size</span><span class="p">)</span>
                <span class="n">raw_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">raw_samples</span><span class="p">)</span>

                <span class="c1"># enforce post-truncation correlations if needed</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tr_limits_post</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tr_lower_post</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tr_upper_post</span>
                    <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ndim</span><span class="p">):</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">lower</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">&gt;</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">upper</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="o">&lt;</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">):</span>
                            <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
                            <span class="n">sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">COV</span><span class="p">[</span><span class="n">dim</span><span class="p">,</span><span class="n">dim</span><span class="p">])</span>
                            <span class="n">samples_U</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">raw_samples</span><span class="p">[</span><span class="n">dim</span><span class="p">],</span><span class="n">loc</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span><span class="n">scale</span><span class="o">=</span><span class="n">sig</span><span class="p">)</span>
                            <span class="n">raw_samples</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">truncnorm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span>
                                <span class="n">samples_U</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">sig</span><span class="p">,</span>
                                <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">lower</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="o">-</span><span class="n">mu</span><span class="p">)</span><span class="o">/</span><span class="n">sig</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="p">(</span><span class="n">upper</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="o">-</span><span class="n">mu</span><span class="p">)</span><span class="o">/</span><span class="n">sig</span><span class="p">)</span>

                <span class="c1"># transform samples back from log space if needed</span>
                <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_return_from_log</span><span class="p">(</span><span class="n">raw_samples</span><span class="p">,</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">_distribution_kind</span><span class="p">)</span>

                <span class="n">samples</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">samples</span><span class="p">),</span>
                                       <span class="n">index</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">sample_size</span><span class="p">),</span>
                                       <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_dimension_tags</span><span class="p">)</span>

                <span class="n">samples</span> <span class="o">=</span> <span class="n">samples</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

                <span class="k">if</span> <span class="n">preserve_order</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ncount</span> <span class="o">&gt;=</span> <span class="n">sample_size</span><span class="p">:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw_data</span><span class="p">[:,</span> <span class="p">:</span><span class="n">sample_size</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw_data</span><span class="p">[:</span><span class="n">sample_size</span><span class="p">]</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s2">&quot;The number of samples requested is larger than &quot;</span>
                            <span class="s2">&quot;number of raw data points available. Either &quot;</span>
                            <span class="s2">&quot;sample without preserving order or reduce the &quot;</span>
                            <span class="s2">&quot;sample size.&quot;</span><span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># generate a random list of indices</span>
                    <span class="n">id_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ncount</span><span class="p">,</span>
                                                <span class="n">size</span><span class="o">=</span><span class="n">sample_size</span><span class="p">)</span>

                    <span class="c1"># get the raw data that corresponds to the random ids</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw_data</span><span class="p">[:,</span> <span class="n">id_list</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw_data</span><span class="p">[</span><span class="n">id_list</span><span class="p">]</span>

                <span class="c1"># put the samples in a DataFrame</span>
                <span class="n">samples</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">samples</span><span class="p">),</span>
                                       <span class="n">index</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">sample_size</span><span class="p">),</span>
                                       <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_dimension_tags</span><span class="p">)</span>

                <span class="n">samples</span> <span class="o">=</span> <span class="n">samples</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Either raw samples or a distribution needs to be defined &quot;</span>
                    <span class="s2">&quot;to sample a random variable.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_samples</span> <span class="o">=</span> <span class="n">samples</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_samples</span></div>

<div class="viewcode-block" id="RandomVariable.orthotope_density"><a class="viewcode-back" href="../../source/pelicun.uq.html#pelicun.uq.RandomVariable.orthotope_density">[docs]</a>    <span class="k">def</span> <span class="nf">orthotope_density</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">upper</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Estimate the probability density within an orthotope for a TMVN distr.</span>

<span class="sd">        Use the mvn_orthotope_density function in this module for the</span>
<span class="sd">        calculation. Pre-defined truncation limits for the RV are automatically</span>
<span class="sd">        taken into consideration. Limits for lognormal distributions shall be</span>
<span class="sd">        provided in linear space - the conversion is performed by the algorithm</span>
<span class="sd">        automatically. Pre- and post-truncation correlation is also considered</span>
<span class="sd">        automatically.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lower: float vector, optional, default: None</span>
<span class="sd">            Lower bound(s) of the orthotope. A scalar value can be used for a</span>
<span class="sd">            univariate RV; a list of bounds is expected in multivariate cases.</span>
<span class="sd">            If the orthotope is not bounded from below in any dimension, use</span>
<span class="sd">            either &#39;None&#39; or assign an infinite value (i.e. -numpy.inf) to</span>
<span class="sd">            that dimension.</span>
<span class="sd">        upper: float vector, optional, default: None</span>
<span class="sd">            Upper bound(s) of the orthotope. A scalar value can be used for a</span>
<span class="sd">            univariate RV; a list of bounds is expected in multivariate cases.</span>
<span class="sd">            If the orthotope is not bounded from above in any dimension, use</span>
<span class="sd">            either &#39;None&#39; or assign an infinite value (i.e. numpy.inf) to</span>
<span class="sd">            that dimension.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        alpha: float</span>
<span class="sd">            Estimate of the probability density within the orthotope.</span>
<span class="sd">        eps_alpha: float</span>
<span class="sd">            Estimate of the error in alpha.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get the orthotope density within the truncation limits</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tr_lower_pre</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tr_upper_pre</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">alpha_0</span> <span class="o">=</span> <span class="mf">1.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alpha_0</span><span class="p">,</span> <span class="n">__</span> <span class="o">=</span> <span class="n">mvn_orthotope_density</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">COV</span><span class="p">,</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">tr_lower_pre</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tr_upper_pre</span><span class="p">)</span>

        <span class="c1"># merge the specified limits with the pre-defined truncation limits</span>
        <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_limits</span><span class="p">([</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">])</span>
        <span class="n">lower</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_move_to_log</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distribution_kind</span><span class="p">)</span>
        <span class="n">upper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_move_to_log</span><span class="p">(</span><span class="n">upper</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distribution_kind</span><span class="p">)</span>

        <span class="c1"># if there are post-truncation correlations defined, transform the</span>
        <span class="c1"># prescribed limits to &#39;pre&#39; type limits</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tr_limits_post</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lower_lim_post</span><span class="p">,</span> <span class="n">upper_lim_post</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tr_lower_post</span><span class="p">,</span>
                                              <span class="bp">self</span><span class="o">.</span><span class="n">tr_upper_post</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ndim</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">((</span><span class="n">lower_lim_post</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">lower</span><span class="p">[</span><span class="n">dim</span><span class="p">])</span>
                     <span class="ow">or</span> <span class="p">(</span><span class="n">upper_lim_post</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">upper</span><span class="p">[</span><span class="n">dim</span><span class="p">])):</span>
                    <span class="n">mu</span> <span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
                    <span class="n">sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">COV</span><span class="p">[</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">])</span>
                    <span class="n">lim_U</span> <span class="o">=</span> <span class="n">truncnorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">([</span><span class="n">lower</span><span class="p">[</span><span class="n">dim</span><span class="p">],</span> <span class="n">upper</span><span class="p">[</span><span class="n">dim</span><span class="p">]],</span>
                                          <span class="n">loc</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">sig</span><span class="p">,</span>
                                          <span class="n">a</span><span class="o">=</span><span class="p">(</span><span class="n">lower_lim_post</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="o">-</span><span class="n">mu</span><span class="p">)</span><span class="o">/</span><span class="n">sig</span><span class="p">,</span>
                                          <span class="n">b</span><span class="o">=</span><span class="p">(</span><span class="n">upper_lim_post</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="o">-</span><span class="n">mu</span><span class="p">)</span><span class="o">/</span><span class="n">sig</span><span class="p">)</span>
                    <span class="n">lim_pre</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">lim_U</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">sig</span><span class="p">)</span>
                    <span class="n">lower</span><span class="p">[</span><span class="n">dim</span><span class="p">],</span> <span class="n">upper</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">lim_pre</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tr_limits_pre</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lower_lim_pre</span><span class="p">,</span> <span class="n">upper_lim_pre</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tr_lower_pre</span><span class="p">,</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">tr_upper_pre</span><span class="p">)</span>
            <span class="n">lower_lim_pre</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">lower_lim_pre</span><span class="p">,</span> <span class="n">lower</span><span class="p">)</span>
            <span class="n">upper_lim_pre</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">upper_lim_pre</span><span class="p">,</span> <span class="n">upper</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lower_lim_pre</span> <span class="o">=</span> <span class="n">lower</span>
            <span class="n">upper_lim_pre</span> <span class="o">=</span> <span class="n">upper</span>

        <span class="c1"># get the orthotope density within the prescribed limits</span>
        <span class="n">alpha</span><span class="p">,</span> <span class="n">eps_alpha</span> <span class="o">=</span> <span class="n">mvn_orthotope_density</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">COV</span><span class="p">,</span>
                                                 <span class="n">lower_lim_pre</span><span class="p">,</span> <span class="n">upper_lim_pre</span><span class="p">)</span>

        <span class="c1"># note that here we assume that the error in alpha_0 is negligible</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">alpha</span> <span class="o">/</span> <span class="n">alpha_0</span><span class="p">,</span> <span class="mf">1.</span><span class="p">),</span> <span class="n">eps_alpha</span> <span class="o">/</span> <span class="n">alpha_0</span></div></div>


<div class="viewcode-block" id="RandomVariableSubset"><a class="viewcode-back" href="../../source/pelicun.uq.html#pelicun.uq.RandomVariableSubset">[docs]</a><span class="k">class</span> <span class="nc">RandomVariableSubset</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Provides convenient access to a subset of components of a RandomVariable.</span>

<span class="sd">    This object is useful when working with multivariate RVs, but it is used in</span>
<span class="sd">    all cases to provide a general approach.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    RV: RandomVariable</span>
<span class="sd">        The potentially multivariate random variable that is accessed through</span>
<span class="sd">        this object.</span>
<span class="sd">    tags: str or list of str</span>
<span class="sd">        A string or list of strings that identify the subset of component we</span>
<span class="sd">        are interested in. These strings shall be among the `dimension_tags` of</span>
<span class="sd">        the RV.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">RV</span><span class="p">,</span> <span class="n">tags</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_RV</span> <span class="o">=</span> <span class="n">RV</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tags</span> <span class="o">=</span> <span class="n">tags</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tags</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the tags corresponding to the components in the RV subset.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># this is very simple for now</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tags</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">samples</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the pre-generated samples of the selected component from the</span>
<span class="sd">        RV distribution.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RV</span><span class="o">.</span><span class="n">samples</span>

        <span class="k">if</span> <span class="n">samples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">samples</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_tags</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

<div class="viewcode-block" id="RandomVariableSubset.sample_distribution"><a class="viewcode-back" href="../../source/pelicun.uq.html#pelicun.uq.RandomVariableSubset.sample_distribution">[docs]</a>    <span class="k">def</span> <span class="nf">sample_distribution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_size</span><span class="p">,</span> <span class="n">preserve_order</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sample the probability distribution assigned to the connected RV.</span>

<span class="sd">        Note that this function will sample the full, potentially multivariate,</span>
<span class="sd">        distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sample_size: int</span>
<span class="sd">            Number of samples requested.</span>
<span class="sd">        preserve_order: bool, default: False</span>
<span class="sd">            Influences sampling from raw data. If True, the samples are copies</span>
<span class="sd">            of the first n rows of the raw data where n is the sample_size. This</span>
<span class="sd">            only works for sample_size &lt;= raw data size. If False, the samples</span>
<span class="sd">            are drawn from the raw data pool with replacement.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        samples: DataFrame</span>
<span class="sd">            Samples of the selected component generated from the distribution.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RV</span><span class="o">.</span><span class="n">sample_distribution</span><span class="p">(</span><span class="n">sample_size</span><span class="p">,</span> <span class="n">preserve_order</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">samples</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_tags</span><span class="p">]</span></div>

<div class="viewcode-block" id="RandomVariableSubset.orthotope_density"><a class="viewcode-back" href="../../source/pelicun.uq.html#pelicun.uq.RandomVariableSubset.orthotope_density">[docs]</a>    <span class="k">def</span> <span class="nf">orthotope_density</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">upper</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the density within the orthotope in the marginal pdf of the RVS.</span>

<span class="sd">        The function considers the influence of every dependent variable in the</span>
<span class="sd">        RV on the marginal pdf of the RVS. Note that such influence only occurs</span>
<span class="sd">        when the RV is a truncated distribution and at least two variables are</span>
<span class="sd">        dependent. Pre- and post-truncation correlation is considered</span>
<span class="sd">        automatically.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lower: float vector, optional, default: None</span>
<span class="sd">            Lower bound(s) of the orthotope. A scalar value can be used for a</span>
<span class="sd">            univariate RVS; a list of bounds is expected in multivariate cases.</span>
<span class="sd">            If the orthotope is not bounded from below in any dimension, use</span>
<span class="sd">            either &#39;None&#39; or assign an infinite value (i.e. -numpy.inf) to</span>
<span class="sd">            that dimension.</span>
<span class="sd">        upper: float vector, optional, default: None</span>
<span class="sd">            Upper bound(s) of the orthotope. A scalar value can be used for a</span>
<span class="sd">            univariate RVS; a list of bounds is expected in multivariate cases.</span>
<span class="sd">            If the orthotope is not bounded from above in any dimension, use</span>
<span class="sd">            either &#39;None&#39; or assign an infinite value (i.e. numpy.inf) to</span>
<span class="sd">            that dimension.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        alpha: float</span>
<span class="sd">            Estimate of the probability density within the orthotope.</span>
<span class="sd">        eps_alpha: float</span>
<span class="sd">            Estimate of the error in alpha.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># get the dimension tags from the parent RV and find the ones that</span>
        <span class="c1"># define this RVS</span>
        <span class="n">dtags</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RV</span><span class="o">.</span><span class="n">dimension_tags</span>
        <span class="k">if</span> <span class="n">dtags</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">dtags</span> <span class="o">=</span> <span class="p">[</span><span class="n">dtags</span><span class="p">]</span>
        <span class="n">sorter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">dtags</span><span class="p">)</span>
        <span class="n">tag_ids</span> <span class="o">=</span> <span class="n">sorter</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">dtags</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tags</span><span class="p">,</span> <span class="n">sorter</span><span class="o">=</span><span class="n">sorter</span><span class="p">)]</span>

        <span class="c1"># prepare the limit vectors and assign the limits to the appropriate</span>
        <span class="c1"># dimensions</span>
        <span class="n">lower_full</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dtags</span><span class="p">))]</span>
        <span class="n">upper_full</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">lower_full</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">lower</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lower_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">lower_full</span><span class="p">)</span>
            <span class="n">lower_full</span><span class="p">[</span><span class="n">tag_ids</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">lower</span><span class="p">)</span>
            <span class="n">lower_full</span> <span class="o">=</span> <span class="n">lower_full</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">upper</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">upper_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">upper_full</span><span class="p">)</span>
            <span class="n">upper_full</span><span class="p">[</span><span class="n">tag_ids</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">upper</span><span class="p">)</span>
            <span class="n">upper_full</span> <span class="o">=</span> <span class="n">upper_full</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

        <span class="c1"># get the alpha value from the parent RV</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RV</span><span class="o">.</span><span class="n">orthotope_density</span><span class="p">(</span><span class="n">lower_full</span><span class="p">,</span> <span class="n">upper_full</span><span class="p">)</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright (c) 2018, Leland Stanford Junior University and The Regents of the University of California

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>